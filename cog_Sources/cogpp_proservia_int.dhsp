SetModuleInfo('$Id: cogpp_proservia_int.dhsp 13192 2019-03-05 14:53:51Z k.bdera $')
;>xdiva
;*
;*		Objet : Nom du programme / module - Programme Cogpp_std.dhsp 
;*

;*
;*		Log	Version		N° modif		Date			Modifications
;*		--------------------------------------------------------------------------------------------------------------
;*		YLEF	P205A			Init			07/2015		Intégration de csv pour validation de commandes clients en BL
;*		YLEF	P205A			FE009			07/2015		Intégration de BL internes				

;*
;*		Procédures / Fonctions				Commentaires
;*		--------------------------------------------------------------------------------------------------------------
;*		InitialiserVariables					Initialisation des variables
;*		Proservia_Integration			
;*		SaisiePage1								Saisie de la première page du masque
;*

;*
;*	Déclarations
;*

;
Include	"gttcz00.dhsp"						;déclarations communes

;
Module	"A5Tm000.dhop"
Module	"A5PmWin.dhop"
Module	"A5PmFlash.dhop"
Module	"Cogtm_000.dhop"						;module de fonctions communes
Module	"gtpmficsql.dhop"
;
			HTmpFile	"gtfdd.dhsd"	gtfi		GTFI		DeleteOnExit

;
Public RecordSQL	"CogRs_Dos.dhoq"					CogRs_SocComp
Public RecordSQL	"gtRsppTab.dhoq"					NatureStock				CogRs_Nst
Public RecordSQL	"gtRsppTab.dhoq"					CodeOperation			CogRs_OP

;
Public Record	"gtfdd.dhsd"			xq						xq_cog			;enregistrement de travail
Public Record	"A5dd.dhsd"			 	A1											; Enregistrement de travail (contient les variables utilisées dans l'envoi de FLASH)
Public Record	"a5dd.dhsd"				MChemin
Public Record	"a5dd.dhsd"				MChemin				mChemin_Work
Public Record	"a5dd.dhsd"				MChemin				mChemin_Ok
Public Record	"a5dd.dhsd"				MChemin				mChemin_Err
Public Record	"cogfdd.dhsd"			Cog_ProserviaInd						; table mémoire
Public Record	"cogfdd.dhsd"			Cog_ProserviaVal
Public Record  "gtfdd.dhsd"			iPAR
Public Record  "gtfdd.dhsd"			mvtl					csvMVTL
Public Record  "gtfdd.dhsd"			mvtl					iMVTL
Public Record  "gtfdd.dhsd"			mvtl					MVTL_Seek
Public Record  "gtfdd.dhsd"			MOUV
Public Record  "gtfdd.dhsd"			MOUV					iMOUV
Public Record  "gtfdd.dhsd"			MOUV					MOUV_Seek
Public Record  "gtfdd.dhsd"			ART
Public Record  "gtfdd.dhsd"			SART
Public Record  "gtfdd.dhsd"			ENT
Public Record  "gtfdd.dhsd"			ENT					ENT_Seek
Public Record  "gtfdd.dhsd"			ENT					iENT
Public Record  "gtfdd.dhsd"			ETS
Public Record  "gtfdd.dhsd"			T017										; Dépôt
Public Record  "gtfdd.dhsd"			T018										; Emplacements
Public Record  "gtfdd.dhsd"			T020										; code opération
Public Record  "gtfdd.dhsd"			T025										; Nature de stock

;
1  id_toolbar	L						;ident barre d'outils
1  id_menu		L						;ident menu
1	AdrProc		16						;adresse des procédures appelées dans le module associé
1	erreur		x		= false		;détermine s'il y a eu des erreurs lors de l'exécution du programme
1	tunnel		1,0	= false
1	ficLg			8,0
1	cptLg			8,0
1	cptPce		8,0
1	ticket		L
1	buffer		3000
1	AdrFunc		16
1	tailleLue	L
1	tabulation	L
1	finFichier	L
1	lId_Valeurs	L
1	lId_csvMvtl	L
1	lId_ENT		L
1	lId_iMOUV	L
1	lId_iMVTL	L
1	lId_CdMouv	L
1	lId_ErrTxt	L
1	valeur		256
1	txtErr		500
1	integ			1,0
1	flux			1						; flux de l'intégrateur de pièce

;KBD 08.01.2019	//18499
1	client_DEV	>gtfdd.dhsd	Tiers	
Public Record	"cogfdd.dhsd"			Cog_ProserviaInd	Cog_ProserviaInd_CLI						; table mémoire

;*
;	Procédures / Fonctions générale
;*

;*
Function Long Tri_ProserviaVal(&A, &B)
;
Record	"cogfdd.dhsd"			Cog_ProserviaVal		A
Record	"cogfdd.dhsd"			Cog_ProserviaVal		B
BeginF
	FReturn(SortCompare(A.Cog_Indice, B.Cog_Indice))
EndF

;*
Function Long	Tri_csvMVTL(&A, &B)
;
Record	"gtfdd.dhsd"		MVTL			A
Record	"gtfdd.dhsd"		MVTL			B
1		cleA		77
1		cleB		77
BeginF

	cleA = [A.Dos A.PiNo A.GrRef A.Depo A.Nst A.Serie]
	cleB = [B.Dos B.PiNo B.GrRef B.Depo B.Nst B.Serie]

	FReturn(SortCompare(cleA, cleB))

EndF

;*
Function Long	Tri_ENT(&A, &B)
;
Record	"gtfdd.dhsd"		ENT			A
Record	"gtfdd.dhsd"		ENT			B
1		cleA		25
1		cleB		25
BeginF

	cleA = [A.Dos A.TiCod A.PiCod A.PiNo A.Tiers]
	cleB = [B.Dos B.TiCod B.PiCod B.PiNo B.Tiers]

	FReturn(SortCompare(cleA, cleB))

EndF

;*
Function Long	Tri_iMVTL(&A, &B)
;
Record	"gtfdd.dhsd"		MVTL			A
Record	"gtfdd.dhsd"		MVTL			B
1		cleA		75
1		cleB		75
BeginF

	cleA = [A.Dos A.PiNo A.Enrno A.GrRef]
	cleB = [B.Dos B.PiNo B.Enrno B.GrRef]

	FReturn(SortCompare(cleA, cleB))

EndF

;*
Function Long	Tri_iMOUV(&A, &B)
;
Record	"gtfdd.dhsd"		MOUV			A
Record	"gtfdd.dhsd"		MOUV			B
1		cleA		75
1		cleB		75
BeginF

	cleA = [A.Dos A.CdNo A.GrRef A.Enrno A.Depo A.Op]
	cleB = [B.Dos B.CdNo B.GrRef B.Enrno B.Depo B.Op]

	FReturn(SortCompare(cleA, cleB))

EndF

;* Initialisation des variables
Function int InitialiserVariables
;
Recordsql	a5rsdos.dhoq	utilisateur						;Utilisateurs

BeginF

	if pingreceive("zechange",mz) <> 0

		;le programme n'a pas été lancé à partir du menu, on recherche l'utilisateur
		utilisateur.init()
		utilisateur.where.exists(system.User)
		if utilisateur.select() = 0

			if not tunnel
				messagebox(modify("%1",left(system.user),translate("Utilisateur %1 non défini dans la base Divalto")),translate("Alerte"),mb_iconexclamation)
			endif
			freturn(false)

		else

			mz.dos		= utilisateur.dos
			mz.etb		= utilisateur.etb
			mz.depo		= utilisateur.depo
			mz.mecle		= "Cogee_Proservia_Int.dhof"
			;mz.micle		= "Cogii_.dhoi"
			mz.mtcle		= "Cogtt_proservia_int.dhop"
			mz.titre2	= "Intégration fichier Proservia"

		endif

	endif

	;
	MZ.TiCod = 'C'
	MZ.PiCod = 2

	;commentaire du programme
	ProgramSetComment(translate("Intégration fichier Proservia"))

	;recherche du dossier et T000
	Seek_Soc(MZ.Dos)
	CogRs_SocComp.Init()
	CogRs_SocComp.Where.PK(SOC.Dos)
	CogRs_SocComp.Select()

	;chargement du masque écran
	xmeload mz.mecle
	xmetitle(mz.titre2)
	XmeInfoPage(mz.mecle,1)						;lire la taille de la page
	XmeSetWindowSize(mz.mecle,1,Harmony.Opara3,Harmony.Opara4)

	;chargement des barres d'outils
	id_toolbar = XmeToolbarGetId (mz.mecle,"MAIN")
	XmeToolbarSetWindow (id_toolbar,mz.mecle,1)

	;chargement du menu
	id_menu = XmeMenuGetId (mz.mecle,"MAIN")
	XmeMenuSetWindow (id_menu,mz.mecle,1)

	;chargement du masque d'impression
	;xmiload mz.micle

	; Contrôle des paramètres
	If CogRs_SocComp.IntBlWorkCh = ' '  OR Controler_Chemin(CogRs_SocComp.Dos, ' ', CogRs_SocComp.IntBlWorkCh)
		Cog_EcritureLivreDeBord("Paramétrage des chemins Proservia incomplet (Dossier - onglet U GIE IRIS).")
		Freturn(FALSE)
	EndIf
	mChemin_Work = mChemin
	mChemin_Work.Chemin = Win_ConvertirEnNomWindows(mChemin_Work.Chemin)

	If CogRs_SocComp.IntBlErrCh = ' '  OR Controler_Chemin(CogRs_SocComp.Dos, ' ', CogRs_SocComp.IntBlErrCh)
		Cog_EcritureLivreDeBord("Paramétrage des chemins Proservia incomplet (Dossier - onglet U GIE IRIS).")
		Freturn(FALSE)
	EndIf
	mChemin_Err = mChemin
	mChemin_Err.Chemin = Win_ConvertirEnNomWindows(mChemin_Err.Chemin)

	If CogRs_SocComp.IntBlOkCh = ' '  OR Controler_Chemin(CogRs_SocComp.Dos, ' ', CogRs_SocComp.IntBlOkCh)
		Cog_EcritureLivreDeBord("Paramétrage des chemins Proservia incomplet (Dossier - onglet U GIE IRIS).")
		Freturn(FALSE)
	EndIf
	mChemin_Ok = mChemin
	mChemin_Ok.Chemin = Win_ConvertirEnNomWindows(mChemin_Ok.Chemin)

	; Init listes
	lId_Valeurs = ListGetId("COG_PROSERVIAVAL")
	GetAdressFunction(' ', "Tri_ProserviaVal", AdrFunc)
	ListMode(lId_Valeurs, 1, AdrFunc)

	lId_csvMvtl = ListGetId("COG_CSVMVTL")
	GetAdressFunction(' ', "Tri_csvMvtl", AdrFunc)
	ListMode(lId_csvMvtl, 1, AdrFunc)

	lId_ENT = ListGetId("COG_PROSERVIAENT")
	GetAdressFunction(' ', "Tri_Ent", AdrFunc)
	ListMode(lId_ENT, 1, AdrFunc)

	lId_iMOUV = ListGetId("LISTE_IMOUV")
	GetAdressFunction('', 'Tri_iMOUV', AdrFunc)
	ListMode(lId_iMOUV, Mode=1, AdrFunc)

	lId_iMVTL = ListGetId("LISTE_IMVTL")
	GetAdressFunction('', 'Tri_iMVTL', AdrFunc)
	ListMode(lId_iMVTL, Mode=1, AdrFunc)

	lId_CdMouv = ListGetId("LISTE_PROSERVIAMOUV")
	lId_ErrTxt = ListGetId("LISTE_ERREURS")

	FReturn(true)

endf

;*
Procedure FinProgramme
;
BeginP

	ListDestroy(lId_CdMouv)
	ListDestroy(lId_csvMvtl)
	ListDestroy(lId_ENT)
	ListDestroy(lId_ErrTxt)
	ListDestroy(lId_iMOUV)
	ListDestroy(lId_iMVTL)
	ListDestroy(lId_Valeurs)

	Cog_EcritureLivreDeBord(translate("<-- Fin programme intégration Proservia"))
	ProgramExit()

EndP

;*
Procedure AfficherTraitement(wSel, wTrt)
;
1		wSel		>gtfdd.dhsd		Lib
1		wTrt		>gtfdd.dhsd		Lib
BeginP

	If not tunnel
	
		xq_cog.Lib(1) = wSel
		xq_cog.Lib(2) = wTrt

		Afficher_Selection()
		Afficher_Traitement()

	EndIf

EndP

;*
function int FiltresOk
beginf

	freturn(true)

endf


;*
;	Traitements
;*

;*
Public Procedure Proservia_FlashMessage
; Modification du corps du message du mail
1		wMsg		S
BeginP

	wMsg = ' '

	ListBegin(lId_ErrTxt)

	Do While ListNext(lId_ErrTxt, txtErr) not in (-1, 0)

		wMsg &= $0D0A
		wMsg &= Left(txtErr)

	WEnd

	A1.MsgTxt = left(A1.MsgTxt) & wMsg

EndP

;*
Function int Proservia_FlashErreur
;	Envoi du flash erreur intégration Proservia
1		wErr		1,0
1		wTxt		S
BeginF

	wErr = A5_Flash_Envoi(CogRs_SocComp.Cog_IntBlFlash, '', '', 0)
	wTxt = "Résultat de l'envoi du flash rapport d'erreur --> "

	Switch wErr
		Case 0
			wTxt &= "Mail envoyé."
		Case 1
			wTxt &= "Impossible de lier les destinataires du flash."
		Case 2
			wTxt &= "Pas de flash erreur intégration Proservia paramétré."
		Case 3
			wTxt &= "Erreur d'ouverture de fonctions MAPI."
		Case 4
			wTxt &= "Impossible d'envoyer le message."

	EndSwitch

	Cog_EcritureLivreDeBord(wTxt)

	FReturn(0)

EndF

;*
Function int Proservia_ChargerMOUV(wTicod, wPiCod, wPiNo, wGrRef, wDepo, wNst)
;
RecordSQL		"GTRSPCE.Dhoq"			Mouvement		wRs_MOUV
1		wTicod		>gtfdd.dhsd 		Ticod
1		wPicod		>gtfdd.dhsd			PiCod
1		wPiNo			>gtfdd.dhsd			PiNo
1		wGrRef		>gtfdd.dhsd			GrRef
	2	wRef			>gtfdd.dhsd			Ref
	2	wSref1		>gtfdd.dhsd			Sref1
	2	wSref2		>gtfdd.dhsd			Sref2
1		wRead			L
1		wDepo			>gtfdd.dhsd			Depo
1		wNst			>gtfdd.dhsd			Nst
BeginF

	ListErase(lId_CdMOUV)

	wRs_MOUV.Init()
	wRs_MOUV.Where.RemoveCondition("")
	wRs_MOUV.Where.Equal_TiCod(wTicod)
	wRs_MOUV.Where.AddCondition("Equal_TiCod")
	wRs_MOUV.Where.Equal_PiCod(wPicod)
	wRs_MOUV.Where.AddCondition("Equal_PiCod")
	wRs_MOUV.Where.Equal_Ref(wRef)
	wRs_MOUV.Where.AddCondition("Equal_Ref")
	wRs_MOUV.Where.Equal_Sref1(wSref1)
	wRs_MOUV.Where.AddCondition("Equal_Sref1")
	wRs_MOUV.Where.Equal_Sref2(wSref2)
	wRs_MOUV.Where.AddCondition("Equal_Sref2")
	wRs_MOUV.Where.Equal_Depo(wDepo)
	wRs_MOUV.Where.AddCondition("Equal_Depo")
	wRs_MOUV.Where.Equal_Nst(wNst)					 
	wRs_MOUV.Where.AddCondition("Equal_Nst")

	Switch2 wPicod
		Case 2
			wRs_MOUV.Where.Equal_CdNo(wPiNo)
			wRs_MOUV.Where.AddCondition("Equal_CdNo")
			wRs_MOUV.Where.Equal_CdCe4('1')
			wRs_MOUV.Where.AddCondition("Equal_CdCe4")
		Default
			FReturn(1) ; autres cas non gérés

	EndSwitch

	wRs_MOUV.OrderBy.Par_CdEnrNo()

	wRead = wRs_MOUV.ReaderOpen()
	wRs_MOUV.ReaderSelect(wRead)

	;
	Do While wRs_MOUV.ReaderNext(wRead) > 0

		ListInsert(lId_CdMOUV, wRs_MOUV.MOUV)

	WEnd

	wRs_MOUV.ReaderClose(wRead)

	FReturn(0)

EndF

;*
Function int Proservia_ListeTraitementC
; traitement de la liste pour création
Record	"gtfdd.dhsd"		MVTL			wMVTL_Prec
1		wErr			1,0  = 0
BeginF

	Init wMVTL_Prec = ' '
	ListBegin(lId_csvMVTL)
	Do While ListNext(lId_csvMVTL, csvMVTL) not in (-1, 0)

		Init MOUV = ' '
		MOUV.Dos		= csvMVTL.Dos
		MOUV.GrRef	= csvMVTL.GrRef
		MOUV.Depo	= csvMVTL.Depo
		MOUV.Op		= csvMVTL.Op
		MOUV.Tiers	= csvMVTL.Tiers

		If ListSeek(lId_iMOUV, MOUV, MOUV_Seek) not in (-1, 0)
			Switch csvMVTL.PiCod
				Case 1
				 	MOUV_Seek.DvQte += csvMVTL.Qte
				Case 2
					MOUV_Seek.CdQte += csvMVTL.Qte
				Case 3
					MOUV_Seek.BlQte += csvMVTL.Qte
				Case 4
					MOUV_Seek.FaQte += csvMVTL.Qte
			EndSwitch
			ListModify(lId_iMOUV, MOUV_Seek)		
		Else
			Switch csvMVTL.PiCod
				Case 1
				 	MOUV.DvQte = csvMVTL.Qte
				Case 2
					MOUV.CdQte = csvMVTL.Qte
				Case 3
					MOUV.BlQte = csvMVTL.Qte
				Case 4
					MOUV.FaQte = csvMVTL.Qte
			EndSwitch
			ListInsert(lId_iMOUV, MOUV)

		EndIf

		ListInsert(lId_iMVTL, csvMVTL)

	WEnd

	FReturn(wErr)

EndF

;*
Function int Proservia_ListeTraitementV
;
Record	"gtfdd.dhsd"		MVTL			wMVTL_Prec
1		wBlQte		>gtfdd.dhsd			BlQte
1		wCdQte		>gtfdd.dhsd			CdQte
1		wErr			1,0  = 0
BeginF

	; lecture des ventil à intégrer triées par cdno / grref
	Init wMVTL_Prec = ' '
	ListBegin(lId_csvMVTL)
	Do While ListNext(lId_csvMVTL, csvMVTL) not in (-1, 0)

		wBlQte = csvMVTL.Qte

		; changement commande / changement référence	/ changement dépôt / changement Nst
		If wMVTL_Prec.PiNo & wMVTL_Prec.GrRef & wMVTL_Prec.Depo & wMVTL_Prec.Nst <> csvMVTL.PiNo & csvMVTL.GrRef & csvMVTL.Depo & csvMVTL.Nst
			MZ.Dos = csvMVTL.Dos
			Proservia_ChargerMOUV(csvMVTL.TiCod, csvMVTL.PiCod, csvMVTL.PiNo, csvMVTL.GrRef, csvMVTL.Depo, csvMVTL.Nst)
		EndIf

		; recherche des quantités à valider sur les MOUV commande
		ListBegin(lId_CdMOUV)
		Do While ListNext(lId_CdMOUV, MOUV) not in (-1, 0)	AND wBlQte > 0

			Init iMVTL 	= ' '
			iMVTL.Dos 	= csvMVTL.Dos
			iMVTL.EnrNo	= MOUV.EnrNo
			iMVTL.GrRef	= csvMVTL.GrRef
			iMVTL.PiNo	= csvMVTL.PiNo
			iMVTL.Serie = csvMVTL.Serie
			iMVTL.Lieu	= csvMVTL.Lieu
			iMVTL.Nst	= csvMVTL.Nst
			iMVTL.Depo	= csvMVTL.Depo

			wCdQte = MOUV.CdQte - MOUV.BlQte
			If wCdQte >= wblqte
				MOUV.BlQte += wBlQte
				iMVTL.Qte = wBlQte
				wBlQte = 0
			Else
				MOUV.BlQte += wCdQte
				wBlQte -= wCdQte
				iMVTL.Qte = wCdQte
			EndIf

			ListModify(lId_CdMOUV, MOUV)
			ListInsert(lId_iMVTL, iMVTL)

		WEnd

		; mémorisation des MOUV avec blQte > 0
		ListBegin(lId_CdMOUV)
		Do While ListNext(lId_CdMOUV, MOUV) not in (-1, 0)	
			If MOUV.BlQte > 0
				If ListSeek(lId_iMOUV, MOUV, MOUV_Seek) not in (-1, 0)
					MOUV_Seek = MOUV
					ListModify(lId_iMOUV, MOUV_Seek)		
				Else
					ListInsert(lId_iMOUV, MOUV)
				EndIf
				If MOUV.BlQte = MOUV.CdQte
					ListDeleteAndPrevious(lId_CdMOUV) 			; toute la quantité commandée est réceptionnée 
				EndIf
			EndIf
		WEnd

		; quantité réceptionnée > quantité restante en commande
		If wBlQte > 0

			txtErr = "Quantité en surplus: " & NoSpaces(wBlQte) & " pour la référence " & left(csvMVTL.Ref) & " sur la commande N°" & csvMVTL.PiNo & "."
			Cog_EcritureLivreDeBord(txtErr)
			ListInsert(lId_ErrTxt, txtErr)
			wErr = TRUE

		EndIf

		wMVTL_Prec = csvMVTL

	WEnd

	FReturn(wErr)

EndF

;*
Function int Proservia_ListeTraitement
; Lecture des éléments à valider
; Constitution du GTFI de validation de pièce
BeginF

	;
	If ListCount(lId_csvMVTL) = 0
		FReturn(1)
	EndIf

	ListErase(lId_iMOUV)
	ListErase(lId_iMVTL)

	;
	Switch flux
		Case 'V'
			AfficherTraitement("Recherche des mouvts commande à valider", "")
			Cog_EcritureLivreDeBord("Recherche des mouvts commande à valider")
			Erreur = Proservia_ListeTraitementV

		Case 'C'
			erreur = Proservia_ListeTraitementC


	EndSwitch



	FReturn(Erreur)
EndF

;*
function int Proservia_FichierOuvrir(wchemin_Loc, &wTicket)
; FALSE --> non ouvert

1		wchemin_Loc		256
1		wticket			L
1		wficSize			L
1		wpFort			1,0

BeginF

	;Cog_EcritureLivreDeBord("Ouverture du fichier")

	wticket = WinCreateFile(wchemin_Loc, GENERIC_READ, 0, "", OPEN_EXISTING, 0, 0)

	If wticket = -1	

		WinCloseHandle(ticket)
		erreur = TRUE
		;Cog_EcritureLivreDeBord("Echec à l'ouverture de: " & wchemin_Loc)

	EndIf

	FReturn(Condition(wticket > 0, True, False))

EndF

;*
Function int Proservia_FichierControlerEntete()
; contrôle que tous les mots clés obligatoires sont bien présents
; 0 --> pas d'erreur
1		wlId_tmp		L		
1		wMotCle		20
1		wMotCle_P	20
1		wIndice		4,0
BeginF

	AfficherTraitement("Contrôle de l'entête de fichier","")
	;Cog_EcritureLivreDeBord("Contrôle de l'entête de fichier")

	ficLg = 1
	Do While WinReadFileRecord(ticket, buffer, tailleLue, finFichier, tabulation)	AND not finFichier AND buffer = ' '
		ficLg++
	WEnd

	; récupération de la position des mots clés
	wlId_tmp = SplitList(buffer, ';')
	ListBegin(wlId_tmp)
	wIndice = 0
	wMotCle_P = ';'
	Init Cog_ProserviaInd = ' '
	init Cog_ProserviaInd_CLI = ''
	Do While ListNext(wlId_tmp, wMotCle) not in (-1, 0)

		If wMotCle <> ';'	 OR (wMotCle = ';' AND wMotCle_P = ';') ; colonne vide en entête --> erreur

			wIndice++
	
			Switch FString('U', wMotCle)
				Case 'DOS'
					Cog_ProserviaInd.Cog_IndDos	= wIndice
				Case 'TICOD'
					Cog_ProserviaInd.Cog_IndTicod	= wIndice
				Case 'PICOD'
					Cog_ProserviaInd.Cog_IndPicod	= wIndice
				Case 'OP'
					Cog_ProserviaInd.Cog_IndOP		= wIndice
				Case 'ETB'
					Cog_ProserviaInd.Cog_IndEtb	= wIndice
				Case 'DEPO'
					Cog_ProserviaInd.Cog_IndDepo	= wIndice
				Case 'PIDT'
					Cog_ProserviaInd.Cog_IndPiDt	= wIndice
				Case 'PIREF'
					Cog_ProserviaInd.Cog_IndPiRef	= wIndice
				Case 'REF'
					Cog_ProserviaInd.Cog_IndRef	= wIndice
				Case 'QTE'
					Cog_ProserviaInd.Cog_IndBlQte	= wIndice
				Case 'SERIE'
					Cog_ProserviaInd.Cog_IndSerie	= wIndice
				Case 'PROJET'
					Cog_ProserviaInd.Cog_IndProjet= wIndice
				Case 'NST'
					Cog_ProserviaInd.Cog_IndNst	= wIndice
				Case 'COG_LOGBLNO'
					Cog_ProserviaInd.Cog_IndLog	= wIndice
				Case 'PINO'
					Cog_ProserviaInd.Cog_IndPiNo	= wIndice
				Case 'LIEU'
					Cog_ProserviaInd.Cog_IndLieu	= wIndice
				Case 'SREF1'
					Cog_ProserviaInd.Cog_IndSref1	= wIndice
				Case 'SREF2'
					Cog_ProserviaInd.Cog_IndSref2	= wIndice
				Case 'TRAIT'
					Cog_ProserviaInd.Cog_IndTrait = wIndice
				Case 'IDTISILOG'
					Cog_ProserviaInd.Cog_IndIsilog= wIndice
				Case 'TIERS'						 ;KBD	 08.01.2019	//18499
					Cog_ProserviaInd_CLI.Cog_IndTicod= wIndice
				Default
					txtErr = "Contrôle entête fichier: mot clé non reconnu:" & wMotCle
					Cog_EcritureLivreDeBord(txtErr)
					ListInsert(lId_ErrTxt, txtErr)
					FReturn(1)

			EndSwitch

		EndIf

		wMotCle_P = wMotCle

	WEnd

	ListDestroy(wlId_tmp)

	; contrôle de la présence des mots clés obligatoires
	If Cog_ProserviaInd.Cog_IndDos = 0
		txtErr = "Mot clé DOS absent."
		Cog_EcritureLivreDeBord(txtErr)
		ListInsert(lId_ErrTxt, txtErr)
		erreur = TRUE
	EndIf
	If Cog_ProserviaInd.Cog_IndOP = 0
		txtErr = "Mot clé OP absent."
		Cog_EcritureLivreDeBord(txtErr)
		ListInsert(lId_ErrTxt, txtErr)
		erreur = TRUE
	EndIf
	If Cog_ProserviaInd.Cog_IndRef = 0
		txtErr = "Mot clé REF absent."
		Cog_EcritureLivreDeBord(txtErr)
		ListInsert(lId_ErrTxt, txtErr)
		erreur = TRUE
	EndIf
	;If Cog_ProserviaInd.Cog_IndNst = 0
	;	Cog_EcritureLivreDeBord("Mot clé NST absent.")
	;	erreur = TRUE
	;EndIf
	;If Cog_ProserviaInd.Cog_IndPiNo = 0
	;	Cog_EcritureLivreDeBord("Mot clé PINO absent.")
	;	erreur = TRUE
	;EndIf
	If Cog_ProserviaInd.Cog_IndBlQte = 0
		txtErr = "Mot clé QTE absent."
		Cog_EcritureLivreDeBord(txtErr)
		ListInsert(lId_ErrTxt, txtErr)
		erreur = TRUE
	EndIf
	If Cog_ProserviaInd.Cog_IndDepo = 0
		txtErr = "Mot clé DEPO absent."
		Cog_EcritureLivreDeBord(txtErr)
		ListInsert(lId_ErrTxt, txtErr)
		erreur = TRUE
	EndIf
	If Cog_ProserviaInd.Cog_IndTicod = 0
		txtErr = "Mot clé TICOD absent."
		Cog_EcritureLivreDeBord(txtErr)
		ListInsert(lId_ErrTxt, txtErr)
		erreur = TRUE
	EndIf
	If Cog_ProserviaInd.Cog_IndPicod = 0
		txtErr = "Mot clé PICOD absent."
		Cog_EcritureLivreDeBord(txtErr)
		ListInsert(lId_ErrTxt, txtErr)
		erreur = TRUE
	EndIf
	If Cog_ProserviaInd.Cog_IndTrait = 0
		flux = 'V'									; flux par défaut du programme
	EndIf
	If erreur
		FReturn(1)
	EndIf

	;Cog_EcritureLivreDeBord("Entête de fichier correcte.")
	FReturn(0)

EndF

;*
Function int Proservia_MVTLControler
; Controle les données de csvMVTL
; 0 --> OK
1		wErr		1,0
BeginF

	wErr = FALSE

	; Dossier
	If csvMVTL.Dos = ' ' OR (SOC.Dos <> csvMVTL.Dos AND Seek_Soc(csvMVTL.Dos) <> 0)
		txtErr = "Ligne n°" & NoSpaces(ficLg) & ": dossier " & csvMVTL.Dos & " inconnu."
		Cog_EcritureLivreDeBord(txtErr)
		ListInsert(lId_ErrTxt, txtErr)
		wErr = TRUE
	Else
		MZ.Dos = SOC.Dos		; nécessaire pour les appels de Lectab
	EndIf

	; Ticod
	If csvMVTL.TiCod not IN ('C', 'I')
		txtErr = "Ligne n°" & NoSpaces(ficLg) & ": Ticod " & csvMVTL.Dos & " --> seuls les clients et tiers internes sont gérés."
		Cog_EcritureLivreDeBord(txtErr)
		ListInsert(lId_ErrTxt, txtErr)
		wErr = TRUE
	EndIf

	; Picod
	If flux = 'V' AND csvMVTL.PiCod <> 2
		txtErr = "Ligne n°" & NoSpaces(ficLg) & ": Picod " & csvMVTL.Dos & " --> seules les commandes sont gérées pour la validation."
		Cog_EcritureLivreDeBord(txtErr)
		ListInsert(lId_ErrTxt, txtErr)
		wErr = TRUE
	EndIf

	; Etb
	If csvMVTL.Etb <> ' ' AND ETS.Etb <> csvMVTL.Etb AND Seek_Ets(csvMVTL.Etb) <> 0
		txtErr = "Ligne n°" & NoSpaces(ficLg) & ": établissement " & csvMVTL.Etb & " inconnu."
		Cog_EcritureLivreDeBord(txtErr)
		ListInsert(lId_ErrTxt, txtErr)
		wErr = TRUE
	ElsIf csvMVTL.Etb = ' ' AND Soc.EntCodN(22) = 2
		txtErr = "Ligne n°" & NoSpaces(ficLg) & ": établissement non renseigné."
		Cog_EcritureLivreDeBord(txtErr)
		ListInsert(lId_ErrTxt, txtErr)
		wErr = TRUE
	EndIf

	; Dépôt 
	If csvMVTL.Depo <> ' ' AND T017.Depo <> csvMVTL.Depo AND Lectab(17, csvMVTL.Depo) <> 0
		txtErr = "Ligne n°" & NoSpaces(ficLg) & ": dépôt " & csvMVTL.Depo & " inconnu."
		Cog_EcritureLivreDeBord(txtErr)
		ListInsert(lId_ErrTxt, txtErr)
		wErr = TRUE
	ElsIf csvMVTL.Depo = ' '
		txtErr = "Ligne n°" & NoSpaces(ficLg) & ": dépôt non renseigné."
		Cog_EcritureLivreDeBord(txtErr)
		ListInsert(lId_ErrTxt, txtErr)
		wErr = TRUE
	EndIf

	; Référence
	If csvMVTL.Ref <> ' ' AND ART.Ref <> csvMVTL.Ref AND Seek_ART(csvMVTL.Ref) <> 0
		txtErr = "Ligne n°" & NoSpaces(ficLg) & ": référence " & csvMVTL.Ref & " inconnue."
		Cog_EcritureLivreDeBord(txtErr)
		ListInsert(lId_ErrTxt, txtErr)
		wErr = TRUE
	ElsIf csvMVTL.Ref = ' '
		txtErr = "Ligne n°" & NoSpaces(ficLg) & ": référence non renseignée."
		Cog_EcritureLivreDeBord(txtErr)
		ListInsert(lId_ErrTxt, txtErr)
		wErr = TRUE
	EndIf

	; sous ref
	If csvMVTL.Sref <> ' ' AND SART.Sref <> csvMVTL.Sref AND Seek_SART(csvMVTL.Ref, csvMVTL.Sref1, csvMVTL.Sref2) <> 0
		txtErr = "Ligne n°" & NoSpaces(ficLg) & ": sous référence " & csvMVTL.SRef & " inconnue."
		Cog_EcritureLivreDeBord(txtErr)
		ListInsert(lId_ErrTxt, txtErr)
		wErr = TRUE
	EndIf

	; code OP
	If csvMVTL.Op <> ' ' AND T020.Op <> csvMVTL.Op AND Lectab(20, csvMVTL.Op) <> 0
		txtErr = "Ligne n°" & NoSpaces(ficLg) & ": code opération " & csvMVTL.OP & " inconnu."
		Cog_EcritureLivreDeBord(txtErr)
		ListInsert(lId_ErrTxt, txtErr)
		wErr = TRUE	
	ElsIf csvMVTL.Op = ' '
		If flux = 'C'
			txtErr = "Ligne n°" & NoSpaces(ficLg) & ": le code opération est obligatoire en création de pièce."
			Cog_EcritureLivreDeBord(txtErr)
			ListInsert(lId_ErrTxt, txtErr)
			wErr = TRUE
		Else
			Init T020 = ' '
		EndIF
	EndiF


	; nature de stock
	If csvMVTL.Nst <> ' ' AND T025.Nst <> csvMVTL.Nst AND Lectab(25, csvMVTL.Nst) <> 0
		txtErr = "Ligne n°" & NoSpaces(ficLg) & ": nature de stock " & csvMVTL.Nst & " inconnue."
		Cog_EcritureLivreDeBord(txtErr)
		ListInsert(lId_ErrTxt, txtErr)
		wErr = TRUE
	ElsIf csvMVTL.Nst = ' '
		If T020.NstO <> ' '
 			csvMVTL.NST = T020.NstO
		Else
			txtErr = "Ligne n°" & NoSpaces(ficLg) & ": impossible de déterminer la nature de stock."
			Cog_EcritureLivreDeBord(txtErr)
			ListInsert(lId_ErrTxt, txtErr)
			wErr = TRUE
		EndIf
	EndIf

	; Nature de stock <--> OP
	If T025.Nst <> ' 'AND T020.Op <> ' ' AND T025.Nst <> T020.NstO
		txtErr = "Ligne n°" & NoSpaces(ficLg) & ": code opération " & csvMVTL.OP & " incomptatible avec nature de stock " & csvMVTL.Nst & "."
		Cog_EcritureLivreDeBord(txtErr)
		ListInsert(lId_ErrTxt, txtErr)
		wErr = TRUE	 
	EndIf

	; emplacement
	If csvMVTL.Lieu <> ' ' AND T018.Lieu <> csvMVTL.Lieu AND Lectab(18, [csvMVTL.Depo csvMVTL.Lieu]) <> 0
		txtErr = "Ligne n°" & NoSpaces(ficLg) & ": emplacement " & csvMVTL.Lieu & " inconnu."
		Cog_EcritureLivreDeBord(txtErr)
		ListInsert(lId_ErrTxt, txtErr)
		wErr = TRUE	 
	EndiF

	; Pièce à valider
	If flux = 'V'
		If csvMVTL.PiNo <> ' ' AND ENT.PiNo <> csvMVTL.PiNo AND Seek_ENT(csvMVTL.TiCod, csvMVTL.PiCod, csvMVTL.PiNo) <> 0
			txtErr = "Ligne n°" & NoSpaces(ficLg) & ": Pièce " & csvMVTL.PiNo & " inconnue."
			Cog_EcritureLivreDeBord(txtErr)
			ListInsert(lId_ErrTxt, txtErr)
			wErr = TRUE
		ElsIf ENT.Ce4 <> '1'
			txtErr = "Ligne n°" & NoSpaces(ficLg) & ": la pièce " & csvMVTL.PiNo & " n'est plus active."
			Cog_EcritureLivreDeBord(txtErr)
			ListInsert(lId_ErrTxt, txtErr)
			wErr = TRUE
		ElsIf csvMVTL.PiNo = ' '
			txtErr = "Ligne n°" & NoSpaces(ficLg) & ": numéro de pièce non renseigné."
			Cog_EcritureLivreDeBord(txtErr)
			ListInsert(lId_ErrTxt, txtErr)
			wErr = TRUE
		EndIf
	EndIf

	; création de pièce
	If flux = 'C' AND csvMVTL.TiCod = 'I'
		csvMVTL.Tiers = SOC.InNo
	EndIf

	FReturn(wErr)

EndF

;*
Function int Proservia_FichierLecture
;
1		wPos		L
1		wInd		4,0
1		wValPrec	256
BeginF

	AfficherTraitement("Lecture du fichier","")
	;Cog_EcritureLivreDeBord("Lecture des lignes du fichier.")

	ficLg = 0
	cptLg = 0

	;
	If Proservia_FichierControlerEntete() <> 0
		erreur = TRUE
		FReturn(1)
	EndIf

	;
	ListErase(lId_ENT)
	ListErase(lId_csvMvtl)

	; lecture des lignes du fichier
	Do While WinReadFileRecord(ticket, buffer, tailleLue, finFichier, tabulation) = TRUE AND finFichier = FALSE

		;Cog_EcritureLivreDeBord("Valeur:" & left(buffer))

		ficLg++
		cptLg++
		ListErase(lId_Valeurs)
		wValPrec = ';'
		wPos = 1
		wInd = 0
		valeur = Split(buffer, wPos, ';', Quotes=2) 
		Do While valeur <> $00

			If valeur <> ';'
				wInd++
				Init Cog_ProserviaVal = ' '
				Cog_ProserviaVal.Cog_Indice = wInd
				Cog_ProserviaVal.Cog_Val256 = valeur
				ListInsert(lId_Valeurs, Cog_ProserviaVal)
			ElsIf valeur = ';' AND wValPrec = ';'				; cellule vide
				wInd++
			EndIf

			wValPrec = valeur
			valeur = Split(buffer, wPos, ';', Quotes=2) 

		WEnd

		; 	Affectation des valeurs
		Init csvMVTL = ' '
		If ListSeek(lId_Valeurs, Cog_ProserviaInd.Cog_IndDos, Cog_ProserviaVal)	not in (-,1,0)		| csvMVTL.Dos		= NoSpaces(Cog_ProserviaVal.Cog_Val256) | EndIf	
		If ListSeek(lId_Valeurs, Cog_ProserviaInd.Cog_IndEtb, Cog_ProserviaVal)	not in (-,1,0)		| csvMVTL.Etb		= Left(Cog_ProserviaVal.Cog_Val256) | EndIf
		If ListSeek(lId_Valeurs, Cog_ProserviaInd.Cog_IndDepo, Cog_ProserviaVal)	not in (-,1,0)	| csvMVTL.Depo		= Left(Cog_ProserviaVal.Cog_Val256) | EndIf
		If ListSeek(lId_Valeurs, Cog_ProserviaInd.Cog_IndTiCod, Cog_ProserviaVal) not in (-,1,0) 	| csvMVTL.TiCod	= NoSpaces(Cog_ProserviaVal.Cog_Val256) | EndIf
		If ListSeek(lId_Valeurs, Cog_ProserviaInd.Cog_IndPiCod, Cog_ProserviaVal) not in (-,1,0) 	| csvMVTL.PiCod	= NoSpaces(Cog_ProserviaVal.Cog_Val256) | EndIf
		If ListSeek(lId_Valeurs, Cog_ProserviaInd.Cog_IndPiNo, Cog_ProserviaVal) not in (-,1,0)	| csvMVTL.PiNo		= NoSpaces(Cog_ProserviaVal.Cog_Val256) | EndIf
		If ListSeek(lId_Valeurs, Cog_ProserviaInd.Cog_IndRef, Cog_ProserviaVal)	 not in (-,1,0) 	| csvMVTL.Ref		= Left(Cog_ProserviaVal.Cog_Val256) | EndIf
		If ListSeek(lId_Valeurs, Cog_ProserviaInd.Cog_IndBlQte, Cog_ProserviaVal) not in (-,1,0) 	| csvMVTL.Qte		= NoSpaces(Cog_ProserviaVal.Cog_Val256) | EndIf
		If ListSeek(lId_Valeurs, Cog_ProserviaInd.Cog_IndSerie, Cog_ProserviaVal) not in (-,1,0) 	| csvMVTL.Serie	= Left(Cog_ProserviaVal.Cog_Val256) | EndIf
		If ListSeek(lId_Valeurs, Cog_ProserviaInd.Cog_IndNst, Cog_ProserviaVal) not in (-,1,0) 	| csvMVTL.Nst		= Left(Cog_ProserviaVal.Cog_Val256) | EndIf
		If ListSeek(lId_Valeurs, Cog_ProserviaInd.Cog_IndOp, Cog_ProserviaVal) not in (-,1,0)		| csvMVTL.Op		= Left(Cog_ProserviaVal.Cog_Val256) | EndIf
		If ListSeek(lId_Valeurs, Cog_ProserviaInd.Cog_IndPiNo, Cog_ProserviaVal) not in (-,1,0)	| csvMVTL.PiNo		= NoSpaces(Cog_ProserviaVal.Cog_Val256) | EndIf
		If ListSeek(lId_Valeurs, Cog_ProserviaInd.Cog_IndSref1, Cog_ProserviaVal) not in (-,1,0)	| csvMVTL.Sref1	= Left(Cog_ProserviaVal.Cog_Val256) | EndIf
		If ListSeek(lId_Valeurs, Cog_ProserviaInd.Cog_IndSref2, Cog_ProserviaVal) not in (-,1,0)	| csvMVTL.Sref2	= Left(Cog_ProserviaVal.Cog_Val256) | EndIf
		If ListSeek(lId_Valeurs, Cog_ProserviaInd.Cog_IndLieu, Cog_ProserviaVal) not in (-,1,0)	| csvMVTL.Lieu		= Left(Cog_ProserviaVal.Cog_Val256) | EndIf
		;ListSeek(lId_Valeurs, Cog_ProserviaInd.Cog_Ind, csvMVTL.	)
		;KBD	08.01.2019	//18499
		if client_DEV = "" and Cog_ProserviaInd_CLI.Cog_IndTicod <> ""
			if Listseek(lId_Valeurs, Cog_ProserviaInd_CLI.Cog_IndTicod, Cog_ProserviaVal) not in (-,1,0)							| client_DEV		= Left(Cog_ProserviaVal.Cog_Val256) | EndIf
 		endif
		;
		If ListSeek(lId_Valeurs, Cog_ProserviaInd.Cog_IndTrait, Cog_ProserviaVal) not in (-,1,0)
			If	flux <> ' ' AND flux <> Left(Cog_ProserviaVal.Cog_Val256)
				txtErr =	"Flux différents dans le fichier, intégration refusée."
				Cog_EcritureLivreDeBord(txtErr)
				ListInsert(lId_ErrTxt, txtErr)
				erreur = TRUE
			Else
				flux = Left(Cog_ProserviaVal.Cog_Val256)
			EndIf
		EndIf

		If Proservia_MVTLControler = 0

			If ListSeek(lId_csvMVTL, csvMVTL, MVTL_Seek) not in (-1, 0)
				MVTL_Seek.Qte += csvMVTL.Qte
				ListModify(lId_csvMVTL, MVTL_Seek)

				; contrôle série --> le champ fait parti du tri, si le seek renvoit un résultat cela signifie que le numéro est déjà présent 
				If MVTL_Seek.Serie = csvMVTL.Serie
					txtErr =	"Numéro de série %1 en doublon pour la référence %2."
					txtErr = Modify("%1", MVTL_Seek.Serie, txtErr)
					txtErr = Modify("%2", MVTL_Seek.Ref, txtErr)
					Cog_EcritureLivreDeBord(txtErr)
					ListInsert(lId_ErrTxt, txtErr)
					erreur = TRUE
				EndIf
			Else
				ListInsert(lId_csvMVTL, csvMVTL)
				; nouvelle ligne --> vérification si l'entête est mémorisée -- ENT a été chargé dans Proservia_MVTLControler dans le cas d'une validation
				If flux <> 'V'
					; préparation entête de pièce
					init ENT = ' '
					ENT.Dos		= csvMVTL.Dos
					ENT.TiCod	= csvMVTL.TiCod
					ENT.PiCod	= csvMVTL.PiCod
					ENT.Tiers	= csvMVTL.Tiers
					ENT.Op		= csvMVTL.Op
					ENT.Etb		= csvMVTL.Etb
					ENT.Depo		= csvMVTL.Depo
				EndIf
				If ListSeek(lId_Valeurs, Cog_ProserviaInd.Cog_IndLog, Cog_ProserviaVal) not in (-,1,0) | ENT.Cog_LogBlNo= NoSpaces(Cog_ProserviaVal.Cog_Val256) | EndIf
				If ListSeek(lId_Valeurs, Cog_ProserviaInd.Cog_IndPiDt, Cog_ProserviaVal) not in (-,1,0)| ENT.PiDt= NoSpaces(Cog_ProserviaVal.Cog_Val256) | EndIf
				If ListSeek(lId_Valeurs, Cog_ProserviaInd.Cog_IndIsilog, Cog_ProserviaVal) not in (-,1,0)| ENT.SU_IDT_REQ_IWS = NoSpaces(Cog_ProserviaVal.Cog_Val256) | EndIf
				If ListSeek(lId_ENT, ENT, ENT_Seek) = 0
					ListInsert(lId_ENT, ENT)
				EndIf
			EndIf

		Else ; controle données à intégrer
			erreur = TRUE
		EndIf
 
		AfficherTraitement("Lecture du fichier", Nospaces(ficLg) & " lignes lues")

	WEnd

	Cog_EcritureLivreDeBord(Nospaces(ficLg) & " lignes lues")

	FReturn(erreur)

EndF

;*
Function int Proservia_EcrireGTFI
; Constitution du GTFI avec les listes lId_iMOUV et lId_iMVTL
1		txtDebug		S	= ' '	
recordsql	gtrsart.dhoq	Decomposition	Decomposition_Loc 
RecordSQL	"COG_CCRSJCA.DHOQ"		CogRs_C3
1	readerCompo	L	
1	qteCompo	>gtfdd.dhsd	CDQTE
BeginF

	AfficherTraitement("Ecriture du GTFI", "")

	ListBegin(lId_ENT)
	Do While ListNext(lId_ENT, ENT_Seek) not in (-1, 0)

		; rupture pièce
		ENT = Condition(Seek_Ent(ENT_Seek.TiCod, ENT_Seek.PiCod, ENT_Seek.PiNo)=0, ENT, ENT_Seek)
		Init iPAR	= ' '
		iPAR.Ce1		= 'I'
		iPAR.Dos		= ENT.Dos
		iPAR.Etb		= ENT.Etb
		iPAR.TiCod	= ENT.TiCod
		iPAR.PiCod	= ENT.PiCod
		iPAR.PiCodF	= Condition(flux='V', 3, 0)
		iPAR.PiNo	= ENT.PiNo
		iPAR.Trait	= flux
		HWrite(GTFI, iPAR)

		;
		Init iENT 	= ' '
		iENT.Ce1		= 'A'
		iENT.Ce4		= '1'
		iENT.Tiers 	= ENT_Seek.Tiers
		;KBD	08.01.2019	//18499
		if ipar.TiCod = 'C' and ipar.PiCod = 1 and flux = 'C'	and client_DEV <> ""
			iENT.Tiers = client_DEV
		endif
		client_DEV = ""
		;
		iENT.Op		= ENT_Seek.Op
		iENT.PiDt	= ENT_Seek.PiDt
		iENT.Depo	= ENT_Seek.Depo
		iENT.SU_IDT_REQ_IWS = ENT_Seek.SU_IDT_REQ_IWS
		Ping("LOGBLNO" & ENT_Seek.TiCod & ENT_Seek.PiCod & ENT_Seek.PiNo, ENT_Seek.Cog_LogBlNo)
		ListDeleteAndPrevious(lId_ENT)
	
		HWrite(GTFI, iENT)

		; Mouvements
		ListBegin(lId_iMOUV)
		Do While ListNext(lId_iMOUV, iMOUV) not in (-1, 0)
	
			If (iMOUV.CdNo = iPAR.PiNo AND iMOUV.Tiers = iENT.Tiers) or (ipar.TiCod = 'C' and ipar.PiCod = 1 and flux = 'C') ;KBD	//Ajout de la deuxièmme condition pour integration DEVIS CLI
				Seek_ART(imouv.Ref)
				if ipar.TiCod = 'C'  and flux = 'C'			 ;Si on est en création on cherche les composant pour chaque article
					qteCompo = 0
					if ipar.PiCod = 1
						qteCompo = imouv.DvQte
					elsif ipar.PiCod = 2
						qteCompo = imouv.CdQte
					endif

					;
					CogRs_C3.Init()
					CogRs_C3.Where.Equal_Cpt(ART.CptV)
					CogRs_C3.Select()
					;
					G3_ClearAllCondition(Decomposition_Loc,true)
					readerCompo = Decomposition_Loc.ReaderOpen()
					Decomposition_Loc.Where.Equal_GrRef(imouv.Ref,imouv.Sref1,imouv.Sref2)
					Decomposition_Loc.Where.AddCondition('','Equal_GrRef')
					Decomposition_Loc.ReaderSelect(readerCompo)
					if Decomposition_Loc.GetCount() >= 1					  ;Article composé
						
						iMOUV.Ce1	= 'C'
						iMOUV.Ce2	= '1'
						iMOUV.CdNo 	= 0
						iMOUV.Axe(3) =	 CogRs_C3.Axe(3)
						iMOUV.Axe(4) =	 CogRs_C3.Axe(4)
						if art.LgTyp = 2										  ;composants  liés
							IMOUV.PvCod = 2
						endif
						HWrite(GTFI, iMOUV)
						; iMVTL
						If CogRs_OP.Op <> iMOUV.Op
							CogRs_OP.Init()
							CogRs_OP.Where.PK(iMOUV.Op)
							CogRs_OP.Select()
						EndIf
				
						ListBegin(lId_iMVTL)
						Do While ListNext(lId_iMVTL, iMVTL) not in (-1, 0)
				
							If iMVTL.EnrNo = iMOUV.EnrNo AND iMVTL.GrRef = iMOUV.GrRef AND iMVTL.PiNo = iPAR.PiNo	AND iMVTL.Depo = iMOUV.Depo AND CogRs_OP.NstO = iMVTL.Nst
				
								iMVTL.Ce1	= 'V'
								iMVTL.PiNo 	= 0
								iMVTL.EnrNo	= 0
								HWrite(GTFI, iMVTL)
								ListDeleteAndPrevious(lId_iMVTL)
							EndIf
						WEnd
						ListDeleteAndPrevious(lId_iMOUV)
						;
						loop Decomposition_Loc.ReaderNext(readerCompo) not in (-1,0)
							CogRs_C3.Init()
							CogRs_C3.Where.Equal_Cpt(ART.CptV)							
							CogRs_C3.Select()
							init Imouv = ''
							iMOUV.Ce1	= 'C'
							iMOUV.Ce2	= '1'
							imouv.GrRef =  Decomposition_Loc.GrRefCo
							iMOUV.Axe(3) =	 CogRs_C3.Axe(3)
							iMOUV.Axe(4) =	 CogRs_C3.Axe(4)
							if art.LgTyp <> 2										  ;composants  liés
								IMOUV.PvCod = 2
							endif
							if art.LgTyp = 2		;Lier les composant
								if ipar.PiCod = 1
									imouv.DvSlg = Decomposition_Loc.LiLg
								elsif ipar.PiCod = 2
									imouv.CdSlg = Decomposition_Loc.LiLg
								endif
							endif
							switch Decomposition_Loc.QteTyp
								case 1 ;QTE proportionelle
									if ipar.PiCod = 1
										imouv.DvQte = qteCompo * Decomposition_Loc.Qte
									elsif ipar.PiCod = 2
										imouv.CdQte = qteCompo * Decomposition_Loc.Qte
									endif
								case 2 ;QTE FIxe
									if ipar.PiCod = 1
										imouv.DvQte =  Decomposition_Loc.Qte
									elsif ipar.PiCod = 2
										imouv.CdQte =  Decomposition_Loc.Qte
									endif
							endswitch
							HWrite(GTFI, iMOUV)
						endloop
						Decomposition_Loc.ReaderClose(readerCompo)
					else
						; iMOUV
						CogRs_C3.Init()
						CogRs_C3.Where.Equal_Cpt(ART.CptV)
						CogRs_C3.Select()
						iMOUV.Axe(3) =	 CogRs_C3.Axe(3)
						iMOUV.Axe(4) =	 CogRs_C3.Axe(4)

						iMOUV.Ce1	= 'C'
						iMOUV.Ce2	= '1'
						iMOUV.CdNo 	= 0
						HWrite(GTFI, iMOUV)
						; iMVTL
						If CogRs_OP.Op <> iMOUV.Op
							CogRs_OP.Init()
							CogRs_OP.Where.PK(iMOUV.Op)
							CogRs_OP.Select()
						EndIf
				
						ListBegin(lId_iMVTL)
						Do While ListNext(lId_iMVTL, iMVTL) not in (-1, 0)
				
							If iMVTL.EnrNo = iMOUV.EnrNo AND iMVTL.GrRef = iMOUV.GrRef AND iMVTL.PiNo = iPAR.PiNo	AND iMVTL.Depo = iMOUV.Depo AND CogRs_OP.NstO = iMVTL.Nst
				
								iMVTL.Ce1	= 'V'
								iMVTL.PiNo 	= 0
								iMVTL.EnrNo	= 0
								HWrite(GTFI, iMVTL)
				
								ListDeleteAndPrevious(lId_iMVTL)
				
							EndIf
				
						WEnd
						ListDeleteAndPrevious(lId_iMOUV)
						;
					endif
				else
					; iMOUV
					iMOUV.Ce1	= 'C'
					iMOUV.Ce2	= '1'
					iMOUV.CdNo 	= 0
					HWrite(GTFI, iMOUV)
					; iMVTL
					If CogRs_OP.Op <> iMOUV.Op
						CogRs_OP.Init()
						CogRs_OP.Where.PK(iMOUV.Op)
						CogRs_OP.Select()
					EndIf
			
					ListBegin(lId_iMVTL)
					Do While ListNext(lId_iMVTL, iMVTL) not in (-1, 0)
			
						If iMVTL.EnrNo = iMOUV.EnrNo AND iMVTL.GrRef = iMOUV.GrRef AND iMVTL.PiNo = iPAR.PiNo	AND iMVTL.Depo = iMOUV.Depo AND CogRs_OP.NstO = iMVTL.Nst
			
							iMVTL.Ce1	= 'V'
							iMVTL.PiNo 	= 0
							iMVTL.EnrNo	= 0
							HWrite(GTFI, iMVTL)
			
							ListDeleteAndPrevious(lId_iMVTL)
			
						EndIf
			
					WEnd
					ListDeleteAndPrevious(lId_iMOUV)
				endif

			EndIf		; test si le mouvement correspond à l'entête
	
		WEnd

	WEnd		; boucle lid_ENT

	;MessageBox(txtDebug, "DEBUG")

	FReturn(0)

EndF

;*							
Procedure Proservia_IntegrationGTFI
;
Record	A5dd.dhsd	M2

1	wResultatHMP			S
1	wparam					S
1	wvaleur				S
1	wPino					>Gtfdd.dhsd	Pino
1	wPicod				>gtfdd.dhsd	Picod
BeginP

	FClose(GTFI)

	Tunnel_Integration_Piece(GTFI.Name, True, Desactiver_MAJWMS=TRUE)
	If PongReceive('Resultat', wResultatHMP) = 0
		Do While HmpRead(wResultatHMP, wparam, wvaleur) = 0 		
			If wparam = "PIECE"
				wPino = HmpSeek(wvaleur, "PINO")
				If wPino > 0
					Cog_EcritureLivreDeBord("  Pièce n° " & nospaces(wPino) & " générée.")
					cptPce++		 
				Else
					txtErr = "Rejet de l'intégrateur de pièce. Message tracé dans le livre de bord."
					ListInsert(lId_ErrTxt, txtErr)
					erreur = TRUE
				EndIf
			EndIf
		WEnd
	EndIf

	Fopen(Gtfi, 'P')
	HErase(GTFI)

EndP

;*
Procedure Proservia_FichierTraitement
;
1		wFic		256
1		wRes		S
1		wSrv		256
1		wNom		256
1		wExt		8
BeginP

	erreur = FALSE	| ListErase(lId_ErrTxt)
	integ	= FALSE

	Cog_EcritureLivreDeBord(translate("--> Interface Proservia: début intégration fichier"))

	wFic	= Win_ConvertirEnNomWindows(xq_cog.Fic)
	FileNameAnalyse(Xq_Cog.Fic, wRes, wSrv, wNom, wExt)
	xq_cog.Fic = Left(mChemin_Work.Chemin) & '/' & left(wNom) & '.' & left(wExt)
	txtErr = "Nom du fichier traité: " & left(wNom) & '.' & left(wExt) | ListInsert(lId_ErrTxt, txtErr)

	If WinMoveFile(wFic, xq_cog.Fic)	AND Proservia_FichierOuvrir(xq_cog.Fic, ticket)

		Cog_EcritureLivreDeBord("Fichier déplacé: " & Left(xq_cog.Fic))

  		If Proservia_FichierLecture()	= 0
			If Proservia_ListeTraitement() = 0
			  Integ = Condition(Proservia_EcrireGTFI() = 0, TRUE, FALSE)
			EndIf
		EndIf
		
		WinCloseHandle(ticket)

		; intégration GTFI
		If Integ = 1 And Not Erreur
			Proservia_IntegrationGTFI
		EndIf

		; 
		wFic = Condition(erreur, mChemin_Err.Chemin, mChemin_Ok.Chemin)
		wFic = Left(wFic) & '/' & left(wNom) & '.' & left(wExt)
		WinMoveFile(xq_cog.Fic, wFic)

	Else ; échec déplacement du fichier
		txtErr = WinGetTextError(WinGetLastError)
		Cog_EcritureLivreDeBord(txtErr)
		ListInsert(lId_ErrTxt, txtErr)
		erreur = TRUE
	EndIf ; test déplacement du fichier

	;
	If erreur
		Proservia_FlashErreur()	
	EndIf

	Cog_EcritureLivreDeBord(translate("<-- Interface Proservia: fin de l'intégration fichier"))

endp


;*
;	Saisie des pages du masque
;*

;*
Public Procedure SaisiePage1
;
1 wFin		1,0	= 0
1 wBufopen 							700 ; zone paramètres
	2 wFlags 						L 
	2 wFiltre 						256 
	2 wIndexFiltre 				X 
	2 wIndexNom 					X 
	2 wIndexExtension 			X 
	2 wRepertoireInitial			256 
	2 wTitre 						80 
	2 wExtensionDefaut 			4
1	wTxt			S

BeginP

	;
	wBufopen = " "
	wFiltre = "*.csv" 
	wIndexFiltre = 3
	wRepertoireInitial = xq_cog.Fic
	wTitre = "Ouverture de fichier"
	wFlags = OFN_FILEMUSTEXIST 
	wExtensionDefaut = " "

	XmeInput(mz.mecle,1,0,xme_mode_goto)

	Do
	                                
		switch harmony.key            ;tests des causes de l'interruption
	
		case harmony.dataarret = 8002
			if Harmony.Sourisbout = Right_Button
				Zoom_Call()
			elsif Harmony.Sourisclic = Double_Click
				Harmony.Retour = Xmenext_Simulation_Touche
				Harmony.Cplretour = k_f8
			endif
		
		case k_f7                ;zoom généralisé
			Zoom_Call()
		
		case k_f8                ;zooms
			Zoom_Call(harmony.arret)
	
		case k_f9                ;abandon
			wFin = 1
	
		case vsw in (k_f10, k_return)
			if messagebox(Translate("Lancer l'intégration du fichier?"),Translate("Confirmation"),MB_YESNO+MB_ICONQUESTION)=idyes
				
				PingLocal("TraceCompteur",False)
				G3_OpenTrace(2,3,4)
				Proservia_FichierTraitement()
				G3_CloseTrace

				;
				wTxt = Translate("Traitement terminé.")
				if erreur
					wTxt &= translate("|Des erreurs ont été détectées.|Consultez le livre de bord")
				endif
				wTxt &= "|"	& nospaces(ficLg) & Translate(" ligne(s) lue(s).")
				MessageBox(wTxt ,translate("Information"),mb_iconexclamation)
	
				wFin=1
	
			endif

		Case Harmony.Dataarret = 1001
				WinGetOpenFileName(wBufopen , xq_cog.Fic)

		endswitch

	while wFin = 0         ;suite de la saisie
		xmenext(harmony.retour,harmony.cplretour)
	wend
		
endp


;*
;	Programme principal
;*
Main
;	
	If PingReceive("xq_cog",xq_cog) = 0
		tunnel	= true
	EndIf

	if InitialiserVariables

		if not tunnel
	
			SaisiePage1
	
		else	;programme piloté
	
			Proservia_FichierTraitement()
	
		endif

	endif
